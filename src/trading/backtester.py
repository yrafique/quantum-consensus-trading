"""
trading_system.backtester
=========================

This module provides a simple backtesting framework to evaluate both
baseline and LLM‑augmented strategies on historical data.  The
backtester processes one ticker at a time: it iterates through the
price series, evaluates the signals defined in ``signals.py``, and
opens or closes positions accordingly.  For each trade it records
whether it was profitable, the holding period, and the profit or
loss.  At the end of the run it computes common performance
statistics such as total return, CAGR, Sharpe ratio and maximum
drawdown.

Because the environment lacks access to real market data, backtests
use synthetic price series generated by ``data_ingestion.fetch_daily_data``.

Strategies
----------

Two strategies are supported:

* ``baseline`` – When a signal is triggered, buy the stock with a
  fixed position size of 10 % of capital, hold until either a 5 %
  profit or a 2 % loss, then close the trade.

* ``llm`` – When a signal is triggered, ask the LLM for a
  recommendation.  If the LLM suggests a buy with confidence ≥ 0.85
  the trade is opened.  The position size is determined using the
  Kelly criterion with the LLM's confidence as the estimated win
  probability and the ratio of target to stop defining the reward to
  risk.  The trade is closed when its stop or target is hit.
"""

from __future__ import annotations

from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

import numpy as np
import pandas as pd

from ..utils import data_ingestion
from . import signals, position_sizer
from ..ai import llm_reasoner
from .config import RISK_FREE_RATE


@dataclass
class TradeOutcome:
    ticker: str
    entry_date: pd.Timestamp
    exit_date: pd.Timestamp
    entry_price: float
    exit_price: float
    size: float
    profit: float
    hit_target: bool


def _simulate_trade(
    df: pd.DataFrame,
    entry_index: int,
    entry_price: float,
    stop: float,
    target: float,
    size: float,
) -> TradeOutcome:
    """Simulate the trade after the entry index until stop/target or end.

    Returns a TradeOutcome with exit details.
    """
    for i in range(entry_index + 1, len(df)):
        high = df["high"].iloc[i]
        low = df["low"].iloc[i]
        date = df["date"].iloc[i]
        # Check for stop or target hit intraday
        if low <= stop:
            exit_price = stop
            profit = (exit_price - entry_price) / entry_price * size
            return TradeOutcome(
                ticker="",
                entry_date=df["date"].iloc[entry_index],
                exit_date=date,
                entry_price=entry_price,
                exit_price=exit_price,
                size=size,
                profit=profit,
                hit_target=False,
            )
        if high >= target:
            exit_price = target
            profit = (exit_price - entry_price) / entry_price * size
            return TradeOutcome(
                ticker="",
                entry_date=df["date"].iloc[entry_index],
                exit_date=date,
                entry_price=entry_price,
                exit_price=exit_price,
                size=size,
                profit=profit,
                hit_target=True,
            )
    # If neither hit, close at last close
    exit_price = df["close"].iloc[-1]
    profit = (exit_price - entry_price) / entry_price * size
    return TradeOutcome(
        ticker="",
        entry_date=df["date"].iloc[entry_index],
        exit_date=df["date"].iloc[-1],
        entry_price=entry_price,
        exit_price=exit_price,
        size=size,
        profit=profit,
        hit_target=profit > 0,
    )


def backtest_ticker(
    ticker: str,
    strategy: str = "baseline",
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    initial_capital: float = 100_000.0,
) -> Dict[str, object]:
    """Backtest a single ticker using the specified strategy.

    Parameters
    ----------
    ticker : str
        The symbol to backtest.
    strategy : {"baseline", "llm"}
        Strategy name.  Baseline uses fixed sizes; llm uses the language model.
    start_date, end_date : str, optional
        Date bounds for the test period.
    initial_capital : float
        Starting capital for the simulation.

    Returns
    -------
    dict
        A dictionary containing performance metrics and trade details.
    """
    df = data_ingestion.fetch_daily_data(ticker, start_date=start_date, end_date=end_date)
    if df.empty or len(df) < 30:
        return {
            "ticker": ticker,
            "trades": [],
            "message": "Not enough data",
        }
    short_float, days_to_cover = data_ingestion.get_short_interest(ticker)
    capital = initial_capital
    trades: List[TradeOutcome] = []

    i = 1  # start from second row to allow previous day comparison
    while i < len(df):
        sub_df = df.iloc[: i + 1].copy()
        # Evaluate signals up to day i
        sig = signals.evaluate_signals(
            ticker,
            sub_df,
            short_float=short_float,
            days_to_cover=days_to_cover,
        )
        if not sig.passes:
            i += 1
            continue
        # Determine if we should enter a trade
        last_close = sub_df["close"].iloc[-1]
        if strategy == "baseline":
            # Fixed sizes: 10% of capital
            size = capital * 0.10
            # Standard 5% target and 2% stop
            entry = last_close
            stop = entry * 0.98
            target = entry * 1.05
            trade = _simulate_trade(df, i, entry, stop, target, size)
            trades.append(trade)
            capital += trade.profit  # update capital with P&L (principal returned automatically)
            i += 1  # move to next day after entry
        elif strategy == "llm":
            # Ask LLM for recommendation
            context = {
                "close": float(last_close),
                "rsi": float(sub_df["rsi"].iloc[-1]),
                "ema21": float(sub_df["ema21"].iloc[-1]),
                "vwap": float(sub_df["vwap"].iloc[-1]),
                "volume": float(sub_df["volume"].iloc[-1]),
                "short_float": short_float,
                "days_to_cover": days_to_cover,
                "bullish_engulfing": bool(sub_df["bullish_engulfing"].iloc[-1]),
                "volume_spike": bool(sig.details["volume_spike"]),
                "short_squeeze": bool(sig.details["short_squeeze"]),
            }
            rec = llm_reasoner.generate_recommendation(ticker, context)
            if rec is None or rec.get("action") != "Buy":
                i += 1
                continue
            entry = rec.get("entry", last_close)
            stop = rec.get("stop", entry * 0.98)
            target = rec.get("target", entry * 1.05)
            confidence = rec.get("confidence", 0.9)
            # Estimate reward/risk ratio; guard against division by zero
            risk = abs(entry - stop)
            reward = abs(target - entry)
            reward_to_risk = reward / risk if risk > 0 else 1.0
            # Use LLM confidence as win probability
            fraction = position_sizer.compute_position_fraction(
                win_prob=confidence,
                reward_to_risk=reward_to_risk,
            )
            size = capital * fraction
            # Simulate trade
            trade = _simulate_trade(df, i, entry, stop, target, size)
            trades.append(trade)
            capital += trade.profit  # update capital with P&L
            i += 1
        else:
            raise ValueError(f"Unknown strategy {strategy}")
    # Compute performance metrics
    total_profit = sum(t.profit for t in trades)
    end_capital = initial_capital + total_profit
    returns = [t.profit / initial_capital for t in trades]  # relative to starting capital
    win_trades = [t for t in trades if t.profit > 0]
    loss_trades = [t for t in trades if t.profit <= 0]
    win_rate = len(win_trades) / len(trades) if trades else 0.0

    # Equity curve using daily closing prices (approx): compute daily returns from price series
    prices = df["close"].values
    daily_returns = np.diff(prices) / prices[:-1]
    if len(daily_returns) > 1:
        avg_daily_return = np.mean(daily_returns)
        vol_daily = np.std(daily_returns)
    else:
        avg_daily_return = 0
        vol_daily = 0
    # Annualise (assuming 252 trading days)
    annual_return = (1 + avg_daily_return) ** 252 - 1
    annual_vol = vol_daily * np.sqrt(252)
    sharpe = (annual_return - RISK_FREE_RATE) / annual_vol if annual_vol > 0 else 0
    # Maximum drawdown from price series
    cumulative = np.cumprod(1 + daily_returns)
    peak = np.maximum.accumulate(cumulative)
    drawdowns = (peak - cumulative) / peak
    max_dd = drawdowns.max() if len(drawdowns) > 0 else 0.0
    return {
        "ticker": ticker,
        "trades": [t.__dict__ for t in trades],
        "total_profit": total_profit,
        "end_capital": end_capital,
        "win_rate": win_rate,
        "sharpe_ratio": sharpe,
        "max_drawdown": max_dd,
        "message": "OK",
    }


__all__ = ["backtest_ticker"]